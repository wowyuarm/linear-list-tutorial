# 第2章：数据结构基础

> 理解什么是数据结构和算法

## 本章学习目标

1. 理解什么是数据结构
2. 理解什么是算法
3. 学会时间复杂度和空间复杂度分析
4. 认识线性表这种数据结构

---

## 第一部分：什么是数据结构？

### 2.1 数据结构的定义

#### 用生活比喻理解

**数据结构 = 整理数据的方式**

就像整理房间：
- 书可以放在书架上（按顺序排列）
- 衣服可以挂在衣架上（一件挂一件）
- 袜子可以放在抽屉里（随意堆放）

不同的整理方式，适合不同的使用场景。

#### 正式定义

**数据结构 = 数据的组织、管理和存储方式**  
**目的：** 高效地访问和修改数据

#### 常见的数据结构

```
线性结构：
• 数组（Array）
• 链表（Linked List）
• 栈（Stack）
• 队列（Queue）

非线性结构：
• 树（Tree）
• 图（Graph）
• 哈希表（Hash Table）
```

---

### 2.2 什么是算法？

#### 用生活比喻理解

**算法 = 解决问题的步骤**

做菜的例子：
```
问题：做一道番茄炒蛋
算法：
1. 打鸡蛋
2. 热锅加油
3. 倒入鸡蛋炒熟
4. 加入番茄
5. 加调料
6. 出锅
```

#### 程序中的算法

```cpp
// 算法：在数组中查找最大值
int findMax(int arr[], int n) {
    int max = arr[0];           // 步骤1：假设第一个是最大
    for (int i = 1; i < n; i++) {  // 步骤2：遍历数组
        if (arr[i] > max) {     // 步骤3：比较
            max = arr[i];       // 步骤4：更新最大值
        }
    }
    return max;                 // 步骤5：返回结果
}
```

#### 算法的特征

1. **有穷性**：有限步骤内完成
2. **确定性**：每步都有明确的定义
3. **输入**：有0个或多个输入
4. **输出**：至少有1个输出
5. **可行性**：每步都可以执行

---

## 第二部分：算法复杂度分析

### 2.3 时间复杂度 - 算法的快慢 ⏱️

#### 为什么要分析时间复杂度？

同一个问题，可能有多种解决方法，哪个更快？

**例子：** 在1000个数中找最大值
- 方法1：逐个比较，需要999次比较
- 方法2：先排序再取最后一个，需要更多次操作

显然方法1更快！

#### 时间复杂度的表示

用 **O()** 表示，称为"大O记号"

常见的时间复杂度（从快到慢）：

| 复杂度 | 名称 | 速度 |
|--------|------|------|
| O(1) | 常数时间 | ⚡⚡⚡ 最快 |
| O(log n) | 对数时间 | ⚡⚡ 很快 |
| O(n) | 线性时间 | ⚡ 一般 |
| O(n log n) | 线性对数 | 还行 |
| O(n²) | 平方时间 | 🐌 慢 |
| O(n³) | 立方时间 | 🐌🐌 很慢 |
| O(2ⁿ) | 指数时间 | 🐌🐌🐌 极慢 |

#### O(1) - 常数时间

不管数据多大，执行时间固定

```cpp
// 访问数组第i个元素
int x = arr[5];              // O(1)

// 简单计算
int sum = a + b;             // O(1)
```

#### O(n) - 线性时间

执行时间与数据量成正比

```cpp
// 遍历数组
for (int i = 0; i < n; i++) {
    cout << arr[i];          // 执行n次，O(n)
}

// 查找元素
for (int i = 0; i < n; i++) {
    if (arr[i] == target) {  // 最坏情况遍历n次，O(n)
        return i;
    }
}
```

#### O(n²) - 平方时间

嵌套循环

```cpp
// 冒泡排序
for (int i = 0; i < n; i++) {        // 外层n次
    for (int j = 0; j < n-1; j++) {  // 内层n次
        if (arr[j] > arr[j+1]) {     // 总共n×n次，O(n²)
            swap(arr[j], arr[j+1]);
        }
    }
}
```

#### O(log n) - 对数时间

每次操作减少一半

```cpp
// 二分查找
int left = 0, right = n - 1;
while (left <= right) {
    int mid = (left + right) / 2;
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
// 数据量翻倍，只多1次操作，O(log n)
```

#### 如何计算时间复杂度？

**规则1：只看最高次项**

```cpp
int sum = 0;                   // O(1)
for (int i = 0; i < n; i++) {  // O(n)
    sum += i;
}
// 总复杂度：O(1) + O(n) = O(n)
```

**规则2：嵌套循环相乘**

```cpp
for (int i = 0; i < n; i++) {        // O(n)
    for (int j = 0; j < n; j++) {    // O(n)
        cout << i * j;
    }
}
// 总复杂度：O(n) × O(n) = O(n²)
```

**规则3：连续代码相加**

```cpp
for (int i = 0; i < n; i++) {        // O(n)
    cout << i;
}
for (int j = 0; j < n; j++) {        // O(n)
    cout << j;
}
// 总复杂度：O(n) + O(n) = O(2n) = O(n)
// 常数倍数可以忽略
```

#### 时间复杂度对比

**数据规模 n = 1000 时：**

| 复杂度 | 操作次数 | 耗时 |
|--------|----------|------|
| O(1) | 1次 | 瞬间完成 |
| O(log n) | ~10次 | 瞬间完成 |
| O(n) | 1,000次 | 很快 |
| O(n log n) | ~10,000次 | 快 |
| O(n²) | 1,000,000次 | 慢 |
| O(2ⁿ) | 无法计算 | 不可接受 |

---

### 2.4 空间复杂度 - 算法的内存占用 💾

#### 什么是空间复杂度？

算法执行过程中需要的额外内存空间

#### O(1) - 常数空间

只用几个变量

```cpp
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += arr[i];
}
// 只用了sum和i两个变量，O(1)
```

#### O(n) - 线性空间

需要额外的数组或列表

```cpp
int* temp = new int[n];    // 额外申请n个空间
for (int i = 0; i < n; i++) {
    temp[i] = arr[i] * 2;
}
delete[] temp;
// 空间复杂度 O(n)
```

#### 空间换时间

有时可以用更多空间来提高速度

**例子：** 斐波那契数列

```cpp
// 方法1：递归，时间O(2ⁿ)，空间O(n)
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}

// 方法2：用数组存储，时间O(n)，空间O(n)
int fib2(int n) {
    int dp[n+1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
// 用空间换时间，速度快很多！
```

---

## 第三部分：认识线性表

### 2.5 什么是线性表？

#### 定义

**线性表 = 一组具有相同类型的数据元素的有限序列**

关键词：
- **相同类型**：都是整数，或都是字符串
- **有限**：元素个数有限
- **序列**：有先后顺序

#### 形象比喻

**线性表 = 排队买票的人群**
- 每个人是一个元素
- 有先后顺序（第1个、第2个...）
- 人数有限

#### 数学表示

```
线性表：(a₁, a₂, a₃, ..., aₙ)

其中：
• n：线性表的长度（元素个数）
• aᵢ：第i个元素
• a₁：第一个元素（表头）
• aₙ：最后一个元素（表尾）
```

#### 例子

```
整数线性表：(1, 3, 5, 7, 9)
字符线性表：('A', 'B', 'C', 'D')
学生线性表：(张三, 李四, 王五)
```

---

### 2.6 线性表的特点

#### 结构特点

1. 有唯一的"第一个"元素
2. 有唯一的"最后一个"元素
3. 除第一个外，每个元素有唯一的前驱
4. 除最后一个外，每个元素有唯一的后继

#### 图解

```
线性表：(a₁, a₂, a₃, a₄, a₅)

a₁ ←→ a₂ ←→ a₃ ←→ a₄ ←→ a₅
↑                         ↑
表头                      表尾

a₁：没有前驱，后继是a₂
a₃：前驱是a₂，后继是a₄
a₅：前驱是a₄，没有后继
```

#### 逻辑结构 vs 物理结构

- **逻辑结构**：数据元素之间的关系（上图的前后关系）
- **物理结构**：数据在计算机中的存储方式

线性表有两种物理结构：
1. **顺序存储**：元素连续存放（数组）
2. **链式存储**：元素分散存放，用指针连接（链表）

---

### 2.7 线性表的基本操作

#### 创建操作
- `InitList(&L)`：初始化线性表L

#### 判断操作
- `Empty(L)`：判断线性表是否为空
- `Length(L)`：获取线性表的长度

#### 查找操作
- `Get(L, i)`：获取第i个元素的值
- `Locate(L, x)`：查找值为x的元素位置

#### 修改操作
- `Insert(&L, i, x)`：在第i个位置插入元素x
- `Delete(&L, i)`：删除第i个元素

#### 遍历操作
- `PrintList(L)`：输出所有元素

#### 图解插入和删除

```
原线性表：(1, 2, 3, 4, 5)

插入操作：在第3个位置插入8
(1, 2, 3, 4, 5)
       ↓ 插入8
(1, 2, 8, 3, 4, 5)

删除操作：删除第2个元素
(1, 2, 8, 3, 4, 5)
    ↓ 删除
(1, 8, 3, 4, 5)
```

---

### 2.8 顺序表 vs 单链表

#### 顺序表（数组实现）

```
内存示意图：
地址      元素
1000      1
1004      2
1008      3
1012      4
1016      5

优点：
✅ 访问快：通过下标直接访问，O(1)
✅ 节省空间：不需要额外的指针

缺点：
❌ 插入删除慢：需要移动元素，O(n)
❌ 大小固定：数组大小在创建时确定
```

#### 单链表（指针实现）

```
内存示意图：
1000: [1|1020] → 1020: [2|1100] → 1100: [3|NULL]
↑                       ↑                 ↑
data=1, next=1020    data=2          data=3

优点：
✅ 插入删除快：只需修改指针，O(1)
✅ 大小灵活：动态分配，可以无限扩展

缺点：
❌ 访问慢：必须从头遍历，O(n)
❌ 额外空间：每个节点需要存储指针
```

#### 对比表

| 操作 | 顺序表 | 单链表 |
|------|--------|--------|
| 创建 | O(1) | O(n) |
| 访问第i个 | O(1) | O(n) |
| 查找元素 | O(n) | O(n) |
| 插入元素 | O(n) | O(1)* |
| 删除元素 | O(n) | O(1)* |

*注：前提是已经找到位置

#### 选择建议

- 频繁访问 → 用**顺序表**
- 频繁插入删除 → 用**单链表**
- 不知道大小 → 用**单链表**
- 空间紧张 → 用**顺序表**

---

## 第2章小结

### 核心概念

✅ **数据结构**：组织数据的方式  
✅ **算法**：解决问题的步骤  
✅ **时间复杂度**：算法的快慢  
✅ **空间复杂度**：算法的内存占用  
✅ **线性表**：有序的元素序列  
✅ **顺序表**：用数组实现的线性表  
✅ **单链表**：用指针链接的线性表  

### 自我检测

1. 能否解释什么是时间复杂度？
2. O(n) 和 O(n²) 哪个更快？
3. 线性表有哪些基本操作？
4. 顺序表和链表的区别是什么？

---

## 练习题

### 练习1：计算时间复杂度

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        cout << i + j;
    }
}
```

### 练习2：设计算法

给定一个数组，如何删除第i个元素？  
写出步骤，并分析时间复杂度。

### 练习3：思考题

为什么单链表插入是O(1)，但总的插入操作是O(n)？

### 答案

- **练习1**：O(n²)
- **练习2**：将i后面的所有元素前移一位，O(n)
- **练习3**：因为要先找到位置，查找是O(n)

### 第1章练习题答案

**练习1：**
```cpp
class Box {
public:
    int value;
    Box() { value = 0; }
    void put(int v) { value = v; }
    int get() { return value; }
};
```

**练习2：**
```cpp
struct Node {
    int data;
    Node* next;
};

Node* n1 = new Node;
n1->data = 10;
Node* n2 = new Node;
n2->data = 20;
n1->next = n2;
n2->next = nullptr;
```

**练习3：**
```cpp
template <typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}
```

---

**下一章：** [第3章：顺序表完整实现](03-sequential-list.md) - 从零开始实现顺序表

[返回目录](../README.md)

