╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║          线性表完全教程 - 第1章：C++基础知识                         ║
║          面向数据结构与C++初学者                                    ║
║          采用费曼学习法 - 像教给别人一样学习                         ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════
【费曼学习法说明】
═══════════════════════════════════════════════════════════════════

费曼学习法的核心理念：
"如果你不能简单地解释一个概念，说明你还没有真正理解它"

学习步骤：
1. 选择一个概念
2. 用自己的话解释给一个外行人听
3. 遇到卡壳的地方，回去重新学习
4. 简化语言，使用类比

本教程将用最简单的语言，最生动的比喻，带你从零开始掌握线性表！


╔═══════════════════════════════════════════════════════════════════╗
║  第一部分：C++基础语法（必备知识）                                  ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
1.1 什么是类（Class）？
───────────────────────────────────────────────────────────────────

【用生活比喻理解】
想象你要造一辆汽车：
• 设计图纸 = 类（Class）
• 实际制造的汽车 = 对象（Object）

类是一个模板，对象是根据模板创建的实体。

【简单例子】
```cpp
// 定义一个学生类（设计图纸）
class Student {
public:
    string name;        // 学生姓名
    int age;           // 学生年龄
    
    void study() {     // 学生的行为
        cout << name << "正在学习" << endl;
    }
};

// 创建对象（制造汽车）
int main() {
    Student xiaoming;      // 创建一个叫小明的学生对象
    xiaoming.name = "小明";
    xiaoming.age = 18;
    xiaoming.study();      // 输出：小明正在学习
}
```

【核心概念】
• class：定义类的关键字
• public：公开的，外部可以访问
• private：私有的，外部不能访问
• 成员变量：类中的数据（如name、age）
• 成员函数：类中的方法（如study()）


───────────────────────────────────────────────────────────────────
1.2 构造函数（Constructor）
───────────────────────────────────────────────────────────────────

【为什么需要构造函数？】
想象你买了一部新手机：
• 构造函数 = 手机的出厂设置
• 它会自动初始化手机的基本配置

【例子】
```cpp
class Phone {
public:
    string brand;
    int battery;
    
    // 构造函数：创建对象时自动调用
    Phone() {
        brand = "未知品牌";
        battery = 100;     // 默认电量100%
        cout << "手机已开机，电量：" << battery << "%" << endl;
    }
    
    // 带参数的构造函数
    Phone(string b, int bat) {
        brand = b;
        battery = bat;
        cout << brand << "手机已开机" << endl;
    }
};

int main() {
    Phone phone1;                    // 调用无参构造函数
    Phone phone2("华为", 80);        // 调用有参构造函数
}
```

【输出】
手机已开机，电量：100%
华为手机已开机

【关键点】
1. 构造函数名字 = 类名
2. 构造函数没有返回值类型
3. 创建对象时自动调用
4. 可以有多个构造函数（重载）


───────────────────────────────────────────────────────────────────
1.3 析构函数（Destructor）
───────────────────────────────────────────────────────────────────

【为什么需要析构函数？】
析构函数 = 清洁工
• 对象要"消失"时，析构函数负责清理现场
• 比如：关闭文件、释放内存、断开连接

【例子】
```cpp
class File {
public:
    string filename;
    
    // 构造函数：打开文件
    File(string name) {
        filename = name;
        cout << "打开文件：" << filename << endl;
    }
    
    // 析构函数：关闭文件
    ~File() {
        cout << "关闭文件：" << filename << endl;
    }
};

int main() {
    File f("data.txt");
    // ... 操作文件
    // 程序结束时，自动调用析构函数
}
```

【输出】
打开文件：data.txt
关闭文件：data.txt

【关键点】
1. 析构函数名 = ~类名
2. 没有参数，没有返回值
3. 对象销毁时自动调用
4. 一个类只能有一个析构函数


───────────────────────────────────────────────────────────────────
1.4 指针（Pointer）- 重点难点
───────────────────────────────────────────────────────────────────

【什么是指针？】
指针 = 地址标签
• 变量存放在内存中
• 指针存放的是变量的地址（门牌号）

【形象比喻】
内存 = 一栋大楼
变量 = 房间里的东西
指针 = 房间的门牌号（如：3楼201室）

【基本语法】
```cpp
int age = 18;           // 普通变量
int* p = &age;          // 指针变量，存放age的地址

cout << age;            // 输出：18（变量的值）
cout << &age;           // 输出：0x7fff5a（变量的地址）
cout << p;              // 输出：0x7fff5a（指针存的地址）
cout << *p;             // 输出：18（通过指针访问变量的值）
```

【图解】
```
内存示意图：
地址        变量名      值
0x7fff5a    age        18
0x7fff6b    p          0x7fff5a

&age  = 取age的地址 = 0x7fff5a
p     = 指针本身 = 0x7fff5a
*p    = 通过指针访问值 = 18
```

【指针的用途】
1. 动态内存分配（new/delete）
2. 实现链表等数据结构
3. 函数参数传递（传地址）
4. 数组访问


【动态内存分配】
```cpp
// 静态分配（栈内存）
int arr[5] = {1, 2, 3, 4, 5};  // 大小固定

// 动态分配（堆内存）
int n = 10;
int* arr2 = new int[n];         // 大小可以是变量
arr2[0] = 100;
delete[] arr2;                  // 用完必须释放
```

【new 和 delete】
```cpp
// 创建单个对象
int* p = new int(10);      // 分配一个int，初始值10
delete p;                  // 释放内存

// 创建数组
int* arr = new int[100];   // 分配100个int的空间
delete[] arr;              // 释放数组内存（注意[]）
```

【常见错误】
```cpp
int* p = new int(5);
delete p;
*p = 10;                   // ❌ 错误！使用已释放的内存

int* q;                    // ❌ 未初始化的指针
*q = 20;                   // ❌ 野指针，崩溃！

// 正确做法
int* p = nullptr;          // 初始化为空指针
if (p != nullptr) {
    *p = 10;
}
```


───────────────────────────────────────────────────────────────────
1.5 引用（Reference）
───────────────────────────────────────────────────────────────────

【什么是引用？】
引用 = 变量的别名（小名）
• 两个名字，指向同一个东西

【例子】
```cpp
int age = 18;
int& myAge = age;      // myAge是age的引用

myAge = 20;            // 修改myAge
cout << age;           // 输出：20（age也变了！）

age = 25;              // 修改age
cout << myAge;         // 输出：25（myAge也变了！）
```

【指针 vs 引用】
```cpp
// 指针
int age = 18;
int* p = &age;
*p = 20;              // 通过指针修改，需要*

// 引用
int& ref = age;
ref = 20;             // 直接修改，更简洁

// 区别：
// 1. 引用必须初始化，指针可以不初始化
// 2. 引用不能改变指向，指针可以
// 3. 引用更安全、更简洁
```

【函数参数传递】
```cpp
// 值传递：复制一份，不影响原变量
void func1(int x) {
    x = 100;
}

// 引用传递：直接操作原变量
void func2(int& x) {
    x = 100;
}

// 指针传递：通过地址操作原变量
void func3(int* x) {
    *x = 100;
}

int main() {
    int a = 10;
    func1(a);
    cout << a;        // 输出：10（未改变）
    
    func2(a);
    cout << a;        // 输出：100（已改变）
    
    func3(&a);
    cout << a;        // 输出：100（已改变）
}
```


───────────────────────────────────────────────────────────────────
1.6 模板（Template）- 泛型编程
───────────────────────────────────────────────────────────────────

【为什么需要模板？】
问题：写一个函数，找两个数的最大值

```cpp
// 如果没有模板，需要为每种类型写一个函数
int max(int a, int b) {
    return a > b ? a : b;
}

double max(double a, double b) {
    return a > b ? a : b;
}

string max(string a, string b) {
    return a > b ? a : b;
}
```

这样太麻烦了！模板可以解决这个问题。

【函数模板】
```cpp
// 使用模板，一次搞定所有类型
template <typename T>        // T是类型参数
T max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    cout << max(10, 20);           // T = int，输出：20
    cout << max(3.14, 2.71);       // T = double，输出：3.14
    cout << max('A', 'B');         // T = char，输出：B
}
```

【类模板】
```cpp
// 定义一个可以存储任意类型的盒子
template <typename DataType>
class Box {
public:
    DataType content;          // 盒子里的东西
    
    void put(DataType item) {
        content = item;
    }
    
    DataType get() {
        return content;
    }
};

int main() {
    Box<int> box1;             // 存放int的盒子
    box1.put(100);
    cout << box1.get();        // 输出：100
    
    Box<string> box2;          // 存放string的盒子
    box2.put("Hello");
    cout << box2.get();        // 输出：Hello
}
```

【模板语法详解】
```cpp
template <typename T>
// template：模板关键字
// typename：类型参数关键字（也可以用class）
// T：类型参数名（可以任意取名，习惯用T）

// 使用时：
Box<int> box;     // 将T替换为int
Box<double> box;  // 将T替换为double
```

【为什么线性表要用模板？】
因为线性表可以存储任何类型的数据：
• 整数线性表：SeqList<int>
• 浮点数线性表：SeqList<double>
• 字符串线性表：SeqList<string>


───────────────────────────────────────────────────────────────────
1.7 数组（Array）
───────────────────────────────────────────────────────────────────

【什么是数组？】
数组 = 一排连续的格子
• 每个格子存放相同类型的数据
• 通过下标访问（下标从0开始）

【定义和使用】
```cpp
// 定义数组
int arr[5];                    // 5个int的数组
int nums[5] = {1, 2, 3, 4, 5}; // 初始化

// 访问元素
cout << nums[0];               // 输出：1（第1个元素）
cout << nums[4];               // 输出：5（第5个元素）
nums[2] = 10;                  // 修改第3个元素

// 遍历数组
for (int i = 0; i < 5; i++) {
    cout << nums[i] << " ";
}
```

【数组的内存布局】
```
数组：int nums[5] = {1, 2, 3, 4, 5};

内存地址    下标    值
0x1000      [0]     1
0x1004      [1]     2
0x1008      [2]     3
0x100C      [3]     4
0x1010      [4]     5

特点：连续存储，访问快速 O(1)
```

【数组 vs 指针】
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;              // 数组名可以当作指针

cout << arr[0];            // 输出：1
cout << *p;                // 输出：1（相同）
cout << *(p + 1);          // 输出：2（指针运算）
cout << p[1];              // 输出：2（指针也可以用下标）
```


───────────────────────────────────────────────────────────────────
1.8 结构体（Struct）
───────────────────────────────────────────────────────────────────

【什么是结构体？】
结构体 = 把不同类型的数据打包在一起

【例子】
```cpp
// 定义学生结构体
struct Student {
    string name;
    int age;
    double score;
};

int main() {
    Student s1;
    s1.name = "张三";
    s1.age = 20;
    s1.score = 95.5;
    
    cout << s1.name << "的成绩是" << s1.score;
}
```

【结构体指针】
```cpp
struct Node {
    int data;
    Node* next;          // 指向下一个Node的指针
};

int main() {
    Node* p = new Node;
    p->data = 10;        // 通过指针访问成员用 ->
    (*p).data = 10;      // 等价写法，但不常用
    
    delete p;
}
```

【struct vs class】
```cpp
// struct：默认是public
struct A {
    int x;  // public
};

// class：默认是private
class B {
    int x;  // private
public:
    int y;  // public
};
```


───────────────────────────────────────────────────────────────────
1.9 异常处理（Exception）
───────────────────────────────────────────────────────────────────

【为什么需要异常处理？】
程序运行时可能出错：
• 数组越界
• 除数为0
• 内存不足
• 文件不存在

异常处理可以优雅地处理这些错误。

【基本语法】
```cpp
try {
    // 可能出错的代码
    int arr[5] = {1, 2, 3, 4, 5};
    int index = 10;
    if (index >= 5) {
        throw "数组越界";     // 抛出异常
    }
    cout << arr[index];
}
catch (const char* msg) {
    // 捕获并处理异常
    cout << "错误：" << msg << endl;
}
```

【输出】
错误：数组越界

【完整例子】
```cpp
double divide(double a, double b) {
    if (b == 0) {
        throw "除数不能为0";
    }
    return a / b;
}

int main() {
    try {
        double result = divide(10, 0);
        cout << result;
    }
    catch (const char* e) {
        cout << "捕获异常：" << e << endl;
    }
    
    cout << "程序继续执行" << endl;
}
```

【输出】
捕获异常：除数不能为0
程序继续执行


───────────────────────────────────────────────────────────────────
1.10 命名空间（Namespace）
───────────────────────────────────────────────────────────────────

【为什么需要命名空间？】
避免名字冲突

【例子】
```cpp
namespace School {
    int score = 100;
}

namespace Company {
    int score = 90;
}

int main() {
    cout << School::score;      // 输出：100
    cout << Company::score;     // 输出：90
}
```

【using namespace】
```cpp
#include <iostream>
using namespace std;      // 使用std命名空间

int main() {
    cout << "Hello";      // 不需要写 std::cout
    cin >> x;             // 不需要写 std::cin
}
```


═══════════════════════════════════════════════════════════════════
【第1章小结】
═══════════════════════════════════════════════════════════════════

我们学习了C++的核心概念：

✓ 类和对象：模板和实例的关系
✓ 构造函数：对象的初始化
✓ 析构函数：对象的清理工作
✓ 指针：内存地址的标签
✓ 引用：变量的别名
✓ 模板：泛型编程，一次编写多次使用
✓ 数组：连续存储的数据
✓ 结构体：组合不同类型的数据
✓ 异常处理：优雅地处理错误
✓ 命名空间：避免名字冲突

【自我检测】
1. 能否用自己的话解释什么是指针？
2. 能否说明指针和引用的区别？
3. 为什么要使用模板？
4. 如何通过指针访问结构体成员？

如果以上问题都能回答，恭喜你！可以进入第2章了。


═══════════════════════════════════════════════════════════════════
【练习题】
═══════════════════════════════════════════════════════════════════

练习1：编写一个Box类
要求：
• 有一个int类型的成员变量value
• 构造函数初始化value为0
• 提供put(int v)和get()方法

练习2：使用指针
创建一个Node结构体，包含int data和Node* next
动态创建两个节点，让第一个节点指向第二个节点

练习3：编写函数模板
编写一个swap函数模板，交换两个任意类型的变量

【答案在下一章末尾】


═══════════════════════════════════════════════════════════════════
下一章预告：数据结构基础 - 什么是线性表？
═══════════════════════════════════════════════════════════════════

