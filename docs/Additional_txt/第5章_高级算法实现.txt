╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║          线性表完全教程 - 第5章：高级算法实现                        ║
║          逆置与排序的完整解析                                       ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════
【本章学习目标】
═══════════════════════════════════════════════════════════════════
1. 掌握顺序表的逆置和排序算法
2. 掌握单链表的逆置和排序算法
3. 理解不同算法的优缺点
4. 学会算法的优化技巧


╔═══════════════════════════════════════════════════════════════════╗
║  第一部分：顺序表的高级算法                                         ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
5.1 顺序表逆置（Reverse）
───────────────────────────────────────────────────────────────────

【问题描述】
将顺序表中的元素顺序反转
例如：{1, 3, 8, 9, 2} → {2, 9, 8, 3, 1}

【算法思想：双指针法】
• 设置两个指针：left（左）和right（右）
• left从0开始，right从length-1开始
• 交换left和right位置的元素
• left右移，right左移
• 当left≥right时停止

【形象比喻】
就像两个人面对面走来，每走一步交换手里的东西
最后在中间相遇，交换完成

【详细图解】
```
原数组：{1, 3, 8, 9, 2}
下标：   0  1  2  3  4

步骤1：left=0, right=4
交换data[0]和data[4]：1↔2
结果：{2, 3, 8, 9, 1}
      ↑           ↑
      left      right

步骤2：left=1, right=3
交换data[1]和data[3]：3↔9
结果：{2, 9, 8, 3, 1}
         ↑     ↑
       left  right

步骤3：left=2, right=2
left==right，停止
最终结果：{2, 9, 8, 3, 1}
```

【代码实现】
```cpp
template <typename DataType>
void SeqList<DataType>::Reverse() {
    int left = 0;                      // 左指针，从头开始
    int right = length - 1;            // 右指针，从尾开始
    DataType temp;                     // 临时变量，用于交换
    
    // 当左指针<右指针时，继续交换
    while (left < right) {
        // 交换data[left]和data[right]
        temp = data[left];
        data[left] = data[right];
        data[right] = temp;
        
        // 指针移动
        left++;                        // 左指针右移
        right--;                       // 右指针左移
    }
}
```

【为什么用while(left < right)？】
```
偶数个元素：{1, 2, 3, 4}
left=0, right=3  交换1↔4
left=1, right=2  交换2↔3
left=2, right=1  left>right，停止 ✓

奇数个元素：{1, 2, 3, 4, 5}
left=0, right=4  交换1↔5
left=1, right=3  交换2↔4
left=2, right=2  left==right，停止 ✓
中间元素3不需要交换
```

【时间复杂度分析】
• 循环次数：length/2
• 每次操作：3次赋值，O(1)
• 总复杂度：O(n/2) = O(n)

【空间复杂度】O(1)
• 只用了temp、left、right三个变量
• 不需要额外的数组

【使用示例】
```cpp
int arr[5] = {1, 3, 8, 9, 2};
SeqList<int> L(arr, 5);
cout << "逆置前：";
L.PrintList();         // 输出：1 3 8 9 2

L.Reverse();           // 调用逆置函数

cout << "逆置后：";
L.PrintList();         // 输出：2 9 8 3 1
```


───────────────────────────────────────────────────────────────────
5.2 顺序表排序（Sort）- 冒泡排序
───────────────────────────────────────────────────────────────────

【问题描述】
将顺序表中的元素按升序排列
例如：{3, 1, 4, 1, 5} → {1, 1, 3, 4, 5}

【算法选择】
常见排序算法对比：
```
算法名称      时间复杂度      稳定性    适用场景
──────────────────────────────────────────
冒泡排序      O(n²)          稳定      小数据量，简单
选择排序      O(n²)          不稳定    小数据量
插入排序      O(n²)          稳定      近似有序
快速排序      O(nlogn)       不稳定    大数据量
归并排序      O(nlogn)       稳定      大数据量
```

我们选择冒泡排序：代码简单，易于理解

【冒泡排序原理】
就像水里的气泡，最大的泡泡会"冒"到最上面

【算法思想】
1. 比较相邻的两个元素
2. 如果前面的大于后面的，交换它们
3. 一轮下来，最大的元素会"冒"到最后
4. 重复n-1轮

【详细图解】
```
原数组：{5, 2, 4, 1, 3}

第1轮：找最大值，放到最后
比较5和2：5>2，交换 → {2, 5, 4, 1, 3}
比较5和4：5>4，交换 → {2, 4, 5, 1, 3}
比较5和1：5>1，交换 → {2, 4, 1, 5, 3}
比较5和3：5>3，交换 → {2, 4, 1, 3, 5}
                               ↑
                          最大值就位

第2轮：找第二大，放到倒数第二
比较2和4：2<4，不交换 → {2, 4, 1, 3, 5}
比较4和1：4>1，交换 → {2, 1, 4, 3, 5}
比较4和3：4>3，交换 → {2, 1, 3, 4, 5}
                            ↑  ↑
                      第二大就位

第3轮：
比较2和1：2>1，交换 → {1, 2, 3, 4, 5}
比较2和3：2<3，不交换 → {1, 2, 3, 4, 5}
                         ↑  ↑  ↑
                    第三大就位

第4轮：
比较1和2：1<2，不交换 → {1, 2, 3, 4, 5}
                         ↑  ↑  ↑  ↑
                    第四大就位

完成！{1, 2, 3, 4, 5}
```

【基础版代码】
```cpp
template <typename DataType>
void SeqList<DataType>::Sort() {
    DataType temp;
    
    // 外层循环：控制轮数（n-1轮）
    for (int i = 0; i < length - 1; i++) {
        
        // 内层循环：进行相邻元素的比较和交换
        for (int j = 0; j < length - 1 - i; j++) {
            
            // 如果前一个大于后一个，交换
            if (data[j] > data[j + 1]) {
                temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
            }
        }
    }
}
```

【为什么j < length - 1 - i？】
```
length = 5

第1轮(i=0)：j从0到3，比较4次
因为最后一个元素已经就位，不需要比较

第2轮(i=1)：j从0到2，比较3次
因为最后两个元素已经就位

第3轮(i=2)：j从0到1，比较2次
第4轮(i=3)：j从0到0，比较1次

总共比较：4+3+2+1 = 10次
```

【优化版代码】
如果某一轮没有发生交换，说明已经有序，可以提前结束

```cpp
template <typename DataType>
void SeqList<DataType>::Sort() {
    bool swapped;          // 标志位，记录是否发生交换
    DataType temp;
    
    // 外层循环：控制排序的轮数
    for (int i = 0; i < length - 1; i++) {
        swapped = false;   // 每轮开始前重置标志位
        
        // 内层循环：进行相邻元素的比较和交换
        for (int j = 0; j < length - 1 - i; j++) {
            if (data[j] > data[j + 1]) {
                // 交换
                temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
                swapped = true;    // 标记发生了交换
            }
        }
        
        // 优化：如果这一轮没有交换，说明已经有序
        if (!swapped) break;
    }
}
```

【优化效果】
```
已排序数组：{1, 2, 3, 4, 5}
第1轮：没有发生交换，swapped=false
直接break，不再继续

时间复杂度从O(n²)优化到O(n)！
```

【时间复杂度分析】
• 最好情况：已排序，O(n)（优化后）
• 最坏情况：逆序，O(n²)
• 平均情况：O(n²)

【空间复杂度】O(1)
• 只用了temp和swapped两个变量

【使用示例】
```cpp
int arr[5] = {5, 2, 4, 1, 3};
SeqList<int> L(arr, 5);
cout << "排序前：";
L.PrintList();         // 输出：5 2 4 1 3

L.Sort();              // 调用排序函数

cout << "排序后：";
L.PrintList();         // 输出：1 2 3 4 5
```


╔═══════════════════════════════════════════════════════════════════╗
║  第二部分：单链表的高级算法                                         ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
5.3 单链表逆置（Reverse）
───────────────────────────────────────────────────────────────────

【问题描述】
将单链表中的节点顺序反转
例如：head → [1] → [3] → [8] → NULL
变为：head → [8] → [3] → [1] → NULL

【算法思想：头插法】
• 将原链表的节点依次摘下来
• 用头插法重新插入到头节点之后
• 相当于重新建立链表

【为什么用头插法？】
头插法天然就是逆序的！

【详细图解】
```
原链表：head → [1] → [3] → [8] → NULL

步骤1：初始化
p指向第1个节点[1]
first->next = NULL（清空链表）

步骤2：摘下[1]，头插
q = p->next（q指向[3]，保存后继）
p->next = first->next（[1]指向NULL）
first->next = p（head指向[1]）
p = q（p指向[3]）
结果：head → [1] → NULL
     p指向[3]

步骤3：摘下[3]，头插
q = p->next（q指向[8]）
p->next = first->next（[3]指向[1]）
first->next = p（head指向[3]）
p = q（p指向[8]）
结果：head → [3] → [1] → NULL
     p指向[8]

步骤4：摘下[8]，头插
q = p->next（q指向NULL）
p->next = first->next（[8]指向[3]）
first->next = p（head指向[8]）
p = q（p指向NULL，循环结束）
结果：head → [8] → [3] → [1] → NULL
```

【代码实现】
```cpp
template <typename DataType>
void LinkList<DataType>::Reverse() {
    Node<DataType>* p = first->next;    // p指向第1个数据节点
    Node<DataType>* q = nullptr;        // q用于暂存p的后继
    
    first->next = nullptr;              // 清空链表
    
    // 遍历原链表的所有节点
    while (p != nullptr) {
        q = p->next;                    // 保存p的后继
        p->next = first->next;          // p插入到头节点之后
        first->next = p;                // 更新头节点的next
        p = q;                          // p移动到下一个节点
    }
}
```

【关键点】
1. 必须用q保存p->next
   因为p->next马上要改变，不保存就找不到后继了
   
2. first->next要先置为nullptr
   作为新链表的初始状态

【与顺序表逆置对比】
```
顺序表：
• 使用双指针，交换元素值
• 需要交换n/2次
• 时间O(n)，空间O(1)

单链表：
• 使用头插法，改变指针
• 需要遍历n个节点
• 时间O(n)，空间O(1)
```

【时间复杂度】O(n)
• 遍历n个节点，每个O(1)操作

【空间复杂度】O(1)
• 只用了p和q两个指针

【使用示例】
```cpp
int arr[3] = {1, 3, 8};
LinkList<int> L(arr, 3);
// 注意：头插法建立，实际是{8, 3, 1}

L.Reverse();           // 逆置
L.PrintList();         // 输出：1 3 8
```


───────────────────────────────────────────────────────────────────
5.4 单链表排序（Sort）- 选择排序
───────────────────────────────────────────────────────────────────

【问题描述】
将单链表中的节点按数据域升序排列

【算法选择】
为什么不用冒泡排序？
• 冒泡排序需要频繁访问相邻节点
• 链表不适合"相邻"的概念

选择排序更适合链表：
• 每次找到最小值
• 交换数据域（不改变指针结构）

【算法思想】
1. 从第1个节点开始，作为当前节点p
2. 从p之后找到最小值节点min
3. 交换p和min的数据域
4. p移动到下一个，重复步骤2-3

【详细图解】
```
原链表：head → [5] → [2] → [4] → [1] → NULL

第1轮：p指向[5]
在[5]后面找最小值：min指向[1]
交换5和1：head → [1] → [2] → [4] → [5] → NULL
                  ↑
                 已排序

第2轮：p指向[2]
在[2]后面找最小值：min指向[2]（自己最小）
不交换：head → [1] → [2] → [4] → [5] → NULL
                  ↑    ↑
                已排序

第3轮：p指向[4]
在[4]后面找最小值：min指向[4]（自己最小）
不交换：head → [1] → [2] → [4] → [5] → NULL
                  ↑    ↑    ↑
                已排序

第4轮：p指向[5]，后面没有节点了
完成！
```

【代码实现】
```cpp
template <typename DataType>
void LinkList<DataType>::Sort() {
    Node<DataType> *p, *q, *min;
    DataType temp;
    
    // 外层循环：p从第1个节点开始
    p = first->next;
    while (p != nullptr) {
        
        // 假设p是最小值
        min = p;
        
        // 内层循环：在p之后找最小值
        q = p->next;
        while (q != nullptr) {
            if (q->data < min->data) {
                min = q;        // 更新最小值节点
            }
            q = q->next;
        }
        
        // 如果最小值不是p自己，交换数据域
        if (min != p) {
            temp = p->data;
            p->data = min->data;
            min->data = temp;
        }
        
        // p移动到下一个节点
        p = p->next;
    }
}
```

【为什么交换数据域而不是调整指针？】
```
交换数据域：
• 简单直接，只需3行代码
• 不改变链表结构

调整指针：
• 复杂，需要记录前驱节点
• 容易出错
• 需要更多代码

对于学习阶段，交换数据域更合适
```

【循环次数分析】
```
n个节点

外层循环：n次
内层循环：
  第1次：n-1次
  第2次：n-2次
  ...
  第n次：0次

总次数：(n-1) + (n-2) + ... + 1 + 0
      = n(n-1)/2
      = O(n²)
```

【时间复杂度】O(n²)
• 两层循环，n×n

【空间复杂度】O(1)
• 只用了p、q、min、temp四个变量

【使用示例】
```cpp
int arr[4] = {5, 2, 4, 1};
LinkList<int> L(arr, 4);
// 头插法建立：{1, 4, 2, 5}

L.Sort();              // 排序
L.PrintList();         // 输出：1 2 4 5
```


╔═══════════════════════════════════════════════════════════════════╗
║  第三部分：算法优化与扩展                                           ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
5.5 组合应用：获得降序排列
───────────────────────────────────────────────────────────────────

【问题】
如何得到降序排列的线性表？

【方法1：修改排序算法】
```cpp
// 将 > 改为 <
if (data[j] < data[j + 1]) {  // 原来是 >
    swap(data[j], data[j+1]);
}
```

【方法2：先升序，再逆置】
```cpp
L.Sort();       // 升序：{1, 2, 3, 4, 5}
L.Reverse();    // 逆置：{5, 4, 3, 2, 1}
```

方法2更好：
• 代码复用，不需要重写排序算法
• 思路清晰，易于理解
• 时间复杂度相同：O(n²) + O(n) = O(n²)


───────────────────────────────────────────────────────────────────
5.6 算法复杂度总结
───────────────────────────────────────────────────────────────────

【顺序表】
```
操作         时间复杂度    空间复杂度    说明
────────────────────────────────────────────
逆置         O(n)         O(1)         双指针法
冒泡排序     O(n²)        O(1)         优化后最好O(n)
```

【单链表】
```
操作         时间复杂度    空间复杂度    说明
────────────────────────────────────────────
逆置         O(n)         O(1)         头插法
选择排序     O(n²)        O(1)         交换数据域
```

【性能对比】
```
对于n=1000的数据：

逆置：
• 顺序表：500次交换
• 单链表：1000次指针操作
• 速度相当

排序：
• 顺序表：最多500000次比较
• 单链表：最多500000次比较
• 速度相当

但顺序表的访问更快，实际上顺序表排序会快一些
```


───────────────────────────────────────────────────────────────────
5.7 进阶：更高效的排序算法
───────────────────────────────────────────────────────────────────

【快速排序：O(nlogn)】
思想：分治法，递归排序
```cpp
void QuickSort(int left, int right) {
    if (left >= right) return;
    int pivot = partition(left, right);
    QuickSort(left, pivot - 1);
    QuickSort(pivot + 1, right);
}
```
优点：速度快
缺点：递归，需要栈空间O(logn)

【归并排序：O(nlogn)】
思想：分治法，合并有序序列
适合链表排序！

【堆排序：O(nlogn)】
思想：利用堆的性质
需要建立堆结构

【对于作业】
• 冒泡排序和选择排序已经足够
• 代码简单，易于理解
• 符合学习阶段的要求


═══════════════════════════════════════════════════════════════════
【第5章小结】
═══════════════════════════════════════════════════════════════════

核心算法：
✓ 顺序表逆置：双指针法，O(n)
✓ 顺序表排序：冒泡排序，O(n²)
✓ 单链表逆置：头插法，O(n)
✓ 单链表排序：选择排序，O(n²)

关键技巧：
✓ 逆置：对称交换
✓ 排序：比较+交换
✓ 优化：提前退出
✓ 组合：先排序再逆置得降序

【算法设计原则】
1. 正确性：算法正确实现功能
2. 可读性：代码清晰易懂
3. 效率性：时间空间复杂度合理
4. 健壮性：处理边界情况


═══════════════════════════════════════════════════════════════════
【练习题】
═══════════════════════════════════════════════════════════════════

练习1：手动模拟冒泡排序
数组：{4, 2, 5, 1, 3}
画出每一轮的变化过程

练习2：实现插入排序
为顺序表编写插入排序算法
时间复杂度应该是O(n²)

练习3：链表排序优化
如何用快速排序优化链表排序到O(nlogn)？
（提示：需要递归和分割链表）

【第4章练习题答案】
练习1：
{5,10,15}，Insert(2,8)
p指向[5]（i-1=1）
s->data=8
s->next=[5]->next（s→[10]）
[5]->next=s（[5]→s）
结果：{5,8,10,15}

练习2：
如果先p->next=s，就丢失了原来的[20]
必须先用s->next保存链接，再改变p->next

练习3：见下一章末尾


═══════════════════════════════════════════════════════════════════
下一章预告：综合应用与实战
═══════════════════════════════════════════════════════════════════

