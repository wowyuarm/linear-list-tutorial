╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║          线性表完全教程 - 第3章：顺序表完整实现                       ║
║          从零开始，一步步实现顺序表                                  ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════
【本章学习目标】
═══════════════════════════════════════════════════════════════════
1. 理解顺序表的存储结构
2. 实现顺序表的基本操作
3. 掌握每个操作的算法思想
4. 学会分析算法的复杂度


╔═══════════════════════════════════════════════════════════════════╗
║  第一部分：顺序表的设计思想                                         ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
3.1 顺序表的物理结构
───────────────────────────────────────────────────────────────────

【核心思想】
用数组存储线性表，元素在内存中连续存放

【形象比喻】
顺序表 = 教室里的座位
• 座位是连续排列的
• 每个座位有编号（0,1,2,3...）
• 可以直接通过编号找到座位

【内存布局】
```
逻辑结构：(10, 20, 30, 40, 50)

物理结构：
下标    0      1      2      3      4      5 ...  99
地址  1000   1004   1008   1012   1016   1020 ... 1396
值     10     20     30     40     50    未用  ... 未用
       ↑                                  ↑
      data[0]                          data[5]

length = 5（当前元素个数）
MaxSize = 100（最大容量）
```

【为什么要限制最大容量？】
• 数组大小在创建时确定
• 避免无限增长导致内存溢出
• 实际应用中可以动态扩容（vector的实现）


───────────────────────────────────────────────────────────────────
3.2 顺序表的类定义
───────────────────────────────────────────────────────────────────

【设计思路】
我们需要什么？
1. 存储数据的数组
2. 记录当前元素个数
3. 各种操作的函数

【第一步：确定成员变量】
```cpp
template <typename DataType>
class SeqList {
private:
    DataType data[MaxSize];    // 存储元素的数组
    int length;                // 当前元素个数
};
```

【为什么用模板？】
让顺序表可以存储任意类型：
```cpp
SeqList<int> list1;        // 存储整数
SeqList<double> list2;     // 存储浮点数
SeqList<string> list3;     // 存储字符串
```

【第二步：确定成员函数】
```cpp
template <typename DataType>
class SeqList {
public:
    // 构造函数
    SeqList();                           // 创建空表
    SeqList(DataType a[], int n);        // 用数组创建
    
    // 基本操作
    int Length();                        // 获取长度
    DataType Get(int i);                 // 按位查找
    int Locate(DataType x);              // 按值查找
    void Insert(int i, DataType x);      // 插入元素
    DataType Delete(int i);              // 删除元素
    int Empty();                         // 判断是否为空
    void PrintList();                    // 打印所有元素
    
private:
    DataType data[MaxSize];              // 数据数组
    int length;                          // 当前长度
};
```

【完整的头文件 SeqList.h】
```cpp
#ifndef SEQLIST_H_INCLUDED
#define SEQLIST_H_INCLUDED

using namespace std;

const int MaxSize = 100;    // 最大容量

template <typename DataType>
class SeqList {
public:
    SeqList();                           // 无参构造函数
    SeqList(DataType a[], int n);        // 有参构造函数
    ~SeqList() {};                       // 析构函数
    int Length() { return length; };     // 返回长度
    DataType Get(int i);                 // 按位查找
    int Locate(DataType x);              // 按值查找
    void Insert(int i, DataType x);      // 插入
    DataType Delete(int i);              // 删除
    int Empty();                         // 判空
    void PrintList();                    // 打印
    
private:
    DataType data[MaxSize];
    int length;
};

#endif
```


╔═══════════════════════════════════════════════════════════════════╗
║  第二部分：构造函数的实现                                           ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
3.3 无参构造函数
───────────────────────────────────────────────────────────────────

【功能】
创建一个空的顺序表

【思路】
只需要将length设为0

【代码实现】
```cpp
template <typename DataType>
SeqList<DataType>::SeqList() {
    length = 0;    // 初始长度为0
}
```

【使用示例】
```cpp
SeqList<int> L;           // 创建空表
cout << L.Length();       // 输出：0
```

【图解】
```
创建后的状态：
下标    0      1      2      3      4
值     未用    未用    未用    未用    未用
       
length = 0（没有元素）
```


───────────────────────────────────────────────────────────────────
3.4 有参构造函数
───────────────────────────────────────────────────────────────────

【功能】
用现有数组创建顺序表

【思路】
1. 检查数组大小是否超出限制
2. 将数组元素复制到data中
3. 设置length

【代码实现】
```cpp
template <typename DataType>
SeqList<DataType>::SeqList(DataType a[], int n) {
    // 步骤1：检查参数合法性
    if (n > MaxSize) {
        throw "参数非法";    // 超出容量，抛出异常
    }
    
    // 步骤2：复制元素
    for (int i = 0; i < n; i++) {
        data[i] = a[i];
    }
    
    // 步骤3：设置长度
    length = n;
}
```

【使用示例】
```cpp
int arr[5] = {1, 2, 3, 4, 5};
SeqList<int> L(arr, 5);    // 用arr创建顺序表
L.PrintList();             // 输出：1 2 3 4 5
```

【图解】
```
输入数组：arr = {1, 2, 3, 4, 5}

复制过程：
arr[0]=1 → data[0]=1
arr[1]=2 → data[1]=2
arr[2]=3 → data[2]=3
arr[3]=4 → data[3]=4
arr[4]=5 → data[4]=5

结果：
下标    0      1      2      3      4      5
值      1      2      3      4      5     未用
       
length = 5
```

【时间复杂度】O(n)
• 循环n次，每次复制一个元素
• 与数组大小成正比


╔═══════════════════════════════════════════════════════════════════╗
║  第三部分：基本操作的实现                                           ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
3.5 打印操作（PrintList）
───────────────────────────────────────────────────────────────────

【功能】
输出顺序表中的所有元素

【思路】
遍历数组，逐个输出

【代码实现】
```cpp
template <typename DataType>
void SeqList<DataType>::PrintList() {
    for (int i = 0; i < length; i++) {
        cout << data[i] << " ";
    }
    cout << endl;
}
```

【使用示例】
```cpp
int arr[5] = {1, 2, 3, 4, 5};
SeqList<int> L(arr, 5);
L.PrintList();    // 输出：1 2 3 4 5
```

【时间复杂度】O(n)
• 遍历length个元素


───────────────────────────────────────────────────────────────────
3.6 按位查找（Get）
───────────────────────────────────────────────────────────────────

【功能】
获取第i个元素的值（i从1开始）

【思路】
1. 检查i是否合法（1 ≤ i ≤ length）
2. 返回data[i-1]（数组下标从0开始）

【为什么i从1开始？】
• 逻辑上：第1个元素、第2个元素...（符合人的习惯）
• 物理上：data[0]、data[1]...（数组下标）
• 关系：第i个元素存在data[i-1]

【代码实现】
```cpp
template <typename DataType>
DataType SeqList<DataType>::Get(int i) {
    // 检查位置是否合法
    if (i < 1 || i > length) {
        throw "查找位置非法";
    }
    
    // 返回第i个元素
    return data[i - 1];    // 注意：i-1
}
```

【使用示例】
```cpp
int arr[5] = {10, 20, 30, 40, 50};
SeqList<int> L(arr, 5);

cout << L.Get(1);    // 输出：10（第1个元素）
cout << L.Get(3);    // 输出：30（第3个元素）
cout << L.Get(5);    // 输出：50（第5个元素）
cout << L.Get(0);    // 抛出异常：查找位置非法
cout << L.Get(6);    // 抛出异常：查找位置非法
```

【图解】
```
顺序表：
位置    1      2      3      4      5
下标    0      1      2      3      4
值     10     20     30     40     50

Get(3)：
位置3 → 下标2 → data[2] → 30
```

【时间复杂度】O(1)
• 直接通过下标访问，不需要循环


───────────────────────────────────────────────────────────────────
3.7 按值查找（Locate）
───────────────────────────────────────────────────────────────────

【功能】
查找值为x的元素，返回其位置

【思路】
1. 从头到尾遍历数组
2. 找到第一个等于x的元素，返回位置
3. 遍历完没找到，返回0

【代码实现】
```cpp
template <typename DataType>
int SeqList<DataType>::Locate(DataType x) {
    // 遍历数组
    for (int i = 0; i < length; i++) {
        if (data[i] == x) {
            return i + 1;    // 找到了，返回位置（i+1）
        }
    }
    
    // 循环结束还没找到
    return 0;                // 返回0表示查找失败
}
```

【使用示例】
```cpp
int arr[5] = {10, 20, 30, 20, 50};
SeqList<int> L(arr, 5);

cout << L.Locate(30);    // 输出：3（30在第3个位置）
cout << L.Locate(20);    // 输出：2（找到第一个20）
cout << L.Locate(99);    // 输出：0（没找到）
```

【图解】
```
顺序表：{10, 20, 30, 20, 50}

查找30：
i=0: data[0]=10 ≠ 30
i=1: data[1]=20 ≠ 30
i=2: data[2]=30 = 30 ✓ 返回i+1=3

查找20：
i=0: data[0]=10 ≠ 20
i=1: data[1]=20 = 20 ✓ 返回i+1=2（第一个）
```

【时间复杂度】O(n)
• 最好情况：第一个就是，O(1)
• 最坏情况：最后一个或不存在，O(n)
• 平均情况：O(n/2) = O(n)


───────────────────────────────────────────────────────────────────
3.8 插入操作（Insert）- 重点难点
───────────────────────────────────────────────────────────────────

【功能】
在第i个位置插入元素x

【思路】
1. 检查是否已满（length == MaxSize）
2. 检查位置是否合法（1 ≤ i ≤ length+1）
3. 将第i个及之后的元素后移一位
4. 在第i个位置放入x
5. 长度加1

【为什么要后移？】
插入位置需要腾出空间

【详细步骤图解】
```
原顺序表：{10, 20, 30, 40, 50}
位置：      1   2   3   4   5

任务：在第3个位置插入8

步骤1：从后往前移动元素
位置    1   2   3   4   5   6
       10  20  30  40  50  空
                   ↓后移
       10  20  30  40  40  50

步骤2：继续后移
       10  20  30  30  40  50

步骤3：插入8
       10  20  8   30  40  50

步骤4：length = 6
```

【为什么从后往前移？】
避免覆盖数据
```
❌ 错误：从前往后
30 → 40位置：data[4] = 30
但data[3]的30还没备份！

✓ 正确：从后往前
50后移：data[5] = data[4]
40后移：data[4] = data[3]
30后移：data[3] = data[2]
```

【代码实现】
```cpp
template <typename DataType>
void SeqList<DataType>::Insert(int i, DataType x) {
    // 步骤1：检查是否已满
    if (length == MaxSize) {
        throw "上溢";    // 表满，无法插入
    }
    
    // 步骤2：检查位置是否合法
    if (i < 1 || i > length + 1) {
        throw "插入位置错误";
    }
    
    // 步骤3：从后往前移动元素
    for (int j = length; j >= i; j--) {
        data[j] = data[j - 1];
    }
    
    // 步骤4：插入元素
    data[i - 1] = x;
    
    // 步骤5：长度加1
    length++;
}
```

【循环详解】
```
原表：{10, 20, 30, 40, 50}，length=5
在第3个位置插入8

for (int j = length; j >= i; j--)
for (int j = 5; j >= 3; j--)

j=5: data[5] = data[4]  → 50后移
j=4: data[4] = data[3]  → 40后移
j=3: data[3] = data[2]  → 30后移

结果：{10, 20, _, 30, 40, 50}
                ↑空位
data[2] = 8
结果：{10, 20, 8, 30, 40, 50}
```

【使用示例】
```cpp
int arr[3] = {1, 3, 5};
SeqList<int> L(arr, 3);

L.Insert(1, 0);    // 在第1个位置插入0
L.PrintList();     // 输出：0 1 3 5

L.Insert(5, 7);    // 在第5个位置（末尾）插入7
L.PrintList();     // 输出：0 1 3 5 7

L.Insert(3, 2);    // 在第3个位置插入2
L.PrintList();     // 输出：0 1 2 3 5 7
```

【时间复杂度】O(n)
• 最好情况：在末尾插入，O(1)
• 最坏情况：在开头插入，移动n个元素，O(n)
• 平均情况：移动n/2个元素，O(n)


───────────────────────────────────────────────────────────────────
3.9 删除操作（Delete）- 重点难点
───────────────────────────────────────────────────────────────────

【功能】
删除第i个元素，并返回其值

【思路】
1. 检查表是否为空
2. 检查位置是否合法（1 ≤ i ≤ length）
3. 保存第i个元素的值
4. 将第i+1个及之后的元素前移一位
5. 长度减1
6. 返回被删除的值

【详细步骤图解】
```
原顺序表：{10, 20, 30, 40, 50}
位置：      1   2   3   4   5

任务：删除第3个位置的元素

步骤1：保存要删除的值
x = data[2] = 30

步骤2：从前往后移动元素
位置    1   2   3   4   5
       10  20  30  40  50
              ↓←前移
       10  20  40  40  50

步骤3：继续前移
       10  20  40  50  50

步骤4：length = 4（最后一个50不用管）
实际表：{10, 20, 40, 50}

步骤5：返回30
```

【为什么从前往后移？】
覆盖要删除的元素
```
删除第3个：
40前移：data[2] = data[3]  （覆盖30）
50前移：data[3] = data[4]
```

【代码实现】
```cpp
template <typename DataType>
DataType SeqList<DataType>::Delete(int i) {
    DataType x;
    
    // 步骤1：检查表是否为空
    if (length == 0) {
        throw "下溢";    // 空表，无法删除
    }
    
    // 步骤2：检查位置是否合法
    if (i < 1 || i > length) {
        throw "删除位置错误";
    }
    
    // 步骤3：保存要删除的元素
    x = data[i - 1];
    
    // 步骤4：从前往后移动元素
    for (int j = i; j < length; j++) {
        data[j - 1] = data[j];
    }
    
    // 步骤5：长度减1
    length--;
    
    // 步骤6：返回被删除的值
    return x;
}
```

【循环详解】
```
原表：{10, 20, 30, 40, 50}，length=5
删除第3个位置

x = data[2] = 30

for (int j = i; j < length; j++)
for (int j = 3; j < 5; j++)

j=3: data[2] = data[3]  → 40前移
j=4: data[3] = data[4]  → 50前移

结果：{10, 20, 40, 50, 50}
length = 4
实际表：{10, 20, 40, 50}（最后一个50不算）
```

【使用示例】
```cpp
int arr[5] = {1, 2, 3, 4, 5};
SeqList<int> L(arr, 5);

int x = L.Delete(3);    // 删除第3个元素
cout << x;              // 输出：3（被删除的值）
L.PrintList();          // 输出：1 2 4 5

x = L.Delete(1);        // 删除第1个元素
cout << x;              // 输出：1
L.PrintList();          // 输出：2 4 5
```

【时间复杂度】O(n)
• 最好情况：删除末尾，O(1)
• 最坏情况：删除开头，移动n-1个元素，O(n)
• 平均情况：移动n/2个元素，O(n)


╔═══════════════════════════════════════════════════════════════════╗
║  第四部分：完整代码汇总                                             ║
╚═══════════════════════════════════════════════════════════════════╝

───────────────────────────────────────────────────────────────────
3.10 SeqList.h（头文件）
───────────────────────────────────────────────────────────────────

```cpp
#ifndef SEQLIST_H_INCLUDED
#define SEQLIST_H_INCLUDED

using namespace std;

// 定义最大容量
const int MaxSize = 100;

// 顺序表类模板
template <typename DataType>
class SeqList {
public:
    SeqList();                         // 无参构造函数
    SeqList(DataType a[], int n);      // 有参构造函数
    ~SeqList() {};                     // 析构函数
    int Length() { return length; };   // 获取长度
    DataType Get(int i);               // 按位查找
    int Locate(DataType x);            // 按值查找
    void Insert(int i, DataType x);    // 插入元素
    DataType Delete(int i);            // 删除元素
    int Empty();                       // 判断是否为空
    void PrintList();                  // 打印所有元素
    
private:
    DataType data[MaxSize];            // 存储元素的数组
    int length;                        // 当前元素个数
};

#endif
```


───────────────────────────────────────────────────────────────────
3.11 SeqList.cpp（实现文件）
───────────────────────────────────────────────────────────────────

```cpp
// 有参构造函数
template <typename DataType>
SeqList<DataType>::SeqList(DataType a[], int n) {
    if (n > MaxSize) throw "参数非法";
    for (int i = 0; i < n; i++)
        data[i] = a[i];
    length = n;
}

// 打印操作
template <typename DataType>
void SeqList<DataType>::PrintList() {
    for (int i = 0; i < length; i++)
        cout << data[i] << " ";
    cout << endl;
}

// 按位查找
template <typename DataType>
DataType SeqList<DataType>::Get(int i) {
    if (i < 1 || i > length) throw "查找位置非法";
    return data[i - 1];
}

// 按值查找
template <typename DataType>
int SeqList<DataType>::Locate(DataType x) {
    for (int i = 0; i < length; i++)
        if (data[i] == x) return i + 1;
    return 0;
}

// 插入操作
template <typename DataType>
void SeqList<DataType>::Insert(int i, DataType x) {
    if (length == MaxSize) throw "上溢";
    if (i < 1 || i > length + 1) throw "插入位置错误";
    for (int j = length; j >= i; j--)
        data[j] = data[j - 1];
    data[i - 1] = x;
    length++;
}

// 删除操作
template <typename DataType>
DataType SeqList<DataType>::Delete(int i) {
    DataType x;
    if (length == 0) throw "下溢";
    if (i < 1 || i > length) throw "删除位置错误";
    x = data[i - 1];
    for (int j = i; j < length; j++)
        data[j - 1] = data[j];
    length--;
    return x;
}
```


═══════════════════════════════════════════════════════════════════
【第3章小结】
═══════════════════════════════════════════════════════════════════

核心知识点：
✓ 顺序表用数组存储，元素连续
✓ length记录元素个数，MaxSize限制容量
✓ 位置从1开始，下标从0开始
✓ 插入：从后往前移动元素
✓ 删除：从前往后移动元素
✓ 访问：O(1)，插入删除：O(n)

【操作总结表】
```
操作         时间复杂度    关键点
──────────────────────────────────
构造函数     O(n)         复制n个元素
按位查找     O(1)         直接访问
按值查找     O(n)         遍历查找
插入         O(n)         移动元素
删除         O(n)         移动元素
打印         O(n)         遍历输出
```


═══════════════════════════════════════════════════════════════════
【练习题】
═══════════════════════════════════════════════════════════════════

练习1：实现判空函数
```cpp
template <typename DataType>
int SeqList<DataType>::Empty() {
    // 请实现：如果为空返回1，否则返回0
}
```

练习2：手动模拟
原表：{5, 10, 15, 20}
执行：Insert(2, 8)
画出每一步的变化

练习3：思考题
为什么插入要从后往前移动，删除要从前往后移动？
如果反过来会怎样？

【答案在下一章末尾】


═══════════════════════════════════════════════════════════════════
下一章预告：单链表的完整实现
═══════════════════════════════════════════════════════════════════

